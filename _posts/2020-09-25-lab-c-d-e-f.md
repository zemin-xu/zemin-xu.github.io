---
layout: post
author: zemin 
category: HCI
demo: true
demo_link: kart_game.mov
---

# Lab C D E F : Learn Unity's ML-Agents package by following tutorial

## Tranditional way vs Machine Learning

Traditional AI is implemented by programmers by setting specific rules and states. For example, for navigation of AI, there are different pathfinding algorithms. Different to traditional way, in machine-learning way we do not provide specific implementation for the AI, also called **agents**. We make them **intelligent** by training them. One way of training is to setup a system of rewards. Like the learning process of children or pets, we make agents learn by giving them rewards or punishment. The agents will try interacting with their environment and they will get different rewards according to their behaviours. The agents will update their way to get the maximum reward. This way is a subset of machine learning and is also call **Reinforcement Learning**. 

## ML-Agents

The Unity Machine Learning Agents Toolkit [ML-Agents](https://github.com/Unity-Technologies/ml-agents) is an open-source project that enables games and simulations to serve as environments for training intelligent agents. Agents can be trained using reinforcement learning, imitation learning, neuroevolution, or other machine learning methods through a simple-to-use Python API.

## Hummingbirds

In this lab we will follow a tutorial on Unity Learn platform called [HummingBirds](https://learn.unity.com/course/ml-agents-hummingbirds). The instuctor is Adam Kelly. According to him:

> We will learn how to create intelligent flying hummingbirds that can navigate to flowers, dip their beaks in, and drink nectar. These hummingbirds have six degrees of freedom, meaning they can fly and turn in any direction to find targets. They have more complicated controls and their flight paths cannot be solved with traditional navigation systems. We will learn how to craft a training environment and train neural networks to perform this challenging task.

In this lab, I will also provide the solutions for potential issues, since the tools like numpy and ML-Agents have upgraded and there will be a little bit of change to make onto the project. 

### Project Setup

#### Initial Setup

Before doing machine-learning stuff, we will firstly setup a unity scene.

Step 1: Choose Universal Render Pipeline template and create a new project.
Step 2: Install the lastest version of *ML Agents* in *Package Manager* panel.

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab2/install_ml_agents.png "install ML Agents package"){:width="100%"}

&nbsp;

Step 3: Import the [assets](https://connect-prd-cdn.unity.com/20200528/36d7a87b-2adb-4dfe-81eb-0444c5ab6e59/HummingbirdScene_1.0.zip?_ga=2.236592129.1011110539.1601564062-1920467459.1600701103) provided by instructor with simple drag & drop into *project* panel, in *Assets* directory. 

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab2/import_assets.png "import assets of projects made by instructor"){:width="100%"}

&nbsp;

Step 4: In the imported directory called *Hummingbirds*, we can find a *Training* scene in *Scenes* sub-directory, double click to open it.
Step 5: Open *Project Settings* panel and enter *Physics* option, and set the *Default Contact Offset* to 0.001. That's because the hummingbird's beck is so small that we have to adjust this variable. 

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab2/change_contact_offset.png "change contact offset"){:width="100%"}

&nbsp;

Step 6: Choose the *Main Camera* and modify its transform's parameters as follow, in order to see the hummingbird in *Game* view.

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab2/main_camera_parameters.png "main camera's transform values"){:width="100%"}

&nbsp;

### Scripts and Tags

We will create three scripts which will be attached to some gameobjects in Unity. The source code will comments be presented in annex. In this main part, I will explain the main ideas of each script.

#### Flower Script

We will implement firstly a **Flower** script by creating a **Scripts** folder and create it there. After that, we will open **FlowerBud** prefab by double clicking on it, and add this script as a component onto the **Flower** gameobject.

&nbsp;

There is already a collider attached to the buds so that the hummingbirds could not put their becks from the sides or from underneath of the buds. We will also find a inner collider which is a trigger inside it which is called **FlowerNectarCollider**. Whenever a hummingbird's beck succeeds in touching this collider, the nectar will be consumed in a few seconds and the bud will turn purple.

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab2/flower_components.png "flower's components"){:width="100%"}

&nbsp;

#### FlowerArea Script

When opening the **FloatingIsland** prefab, we can find that it group up the environment of our training. We will create a **FlowerArea** script and attach it to the **FloatingIsland** gameobject.

&nbsp;

We have seen **FlowerBud** prefab. When discovering **FlowerPlant** prefab, we will find that three buds are onto it. These plants will be randomly instantiate all around the island, with the orientation of each plant a bit different, and this task is managed by *FlowerArea* script. It is also reponsible for resetting the flowers when a new training starts.

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab2/floating_island_components.png "floating island's components"){:width="100%"}

&nbsp;

#### HummingbirdAgent Script

The last script named **HummingbirdAgent** will be attached onto the **HummingBird** gameobject. It contains most of the critical functionality for training our birds and the way of interacting with other objects in scene. It will inherit the **Agent** class in *ML-Agents* package in order to use the machine learning framework in it, that's to say, we will override some functions like **OnEpisodeBegin()** to add custom logics when activating the trainings.

&nbsp;

<details>
  <summary>code</summary>
    ```c#
    public class Order
    {
        public int OrderId { get; set; }
        public int CustomerId { get; set; }

        public List<int> Products { get; set; }
    }
    ```
</details>

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab2/hummingbird_components.png "floating island's components"){:width="100%"}


Before looking into this script, we need to see two specific terms in **reinforcement Learning** -- observation and reward.

##### Observation

ML-Agents enable us to monitor several properties when training the hummingbirds, like the value of position or rotation. To make it simple, we will make a simplfied model and choose the values to be monitored. These values are also called observations. We will override **CollectObservations** in *ML-Agents* to register these chosen values so that the training system will keep observing these values when do training and related them with rewards. In this project, the instructor choose the following observations:
bird's rotation, direction to the nearest's flower and distance to it.

```c#

// observe the agent's local rotation (4 observations)
sensor.AddObservation(transform.localRotation.normalized);

// get a vector from the beak tip to the nearest flower
Vector3 toFlower = nearestFlower.FlowerCenterposition - beakTip.position;

// observe a normalized vector pointing to the nearest flower (3 observations)
sensor.AddObservation(toFlower.normalized);

// observe a dot product that indicates whether the beak tip is in front of the flower
//(+1 means that the beak tip is directly in front of the flower, -1 means directly behind)
sensor.AddObservation(Vector3.Dot(toFlower.normalized, -nearestFlower.FlowerUpVector.normalized));

// observe adot product that indicated whether the beak is pointing toward the flower
//(+1 means that the beak tip is pointing directly at the flower, -1 means directly away
sensor.AddObservation(Vector3.Dot(beakTip.forward.normalized, -nearestFlower.FlowerUpVector.normalized));

// observe the relative distance from the beak tip to the flower (1 observation)
sensor.AddObservation(toFlower.magnitude / FlowerArea.AreaDiameter);
```

##### reward

positive, negative

turn to the nearest flower : 10p
move to : 1p
get beck into it : 100p
finish a flower: 10000p

   
ideas in tuto:
a small positive : birds beak in flower
a big negative : touching ground and rocks

## References

[Flower script](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab2/flower.cs")
[FlowerArea script]()
[HummingbirdAgent script]()

&nbsp;

## Annex

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Manages a collection of flower plants and attached flowers
/// </summary>
public class FlowerArea : MonoBehaviour
{
    // The diameter of the area where the agent and flowers can be
    // used for observing relative distance from agent to flower
    public const float AreaDiameter = 20f;

    // The list of all flower plants in this flower area (flower plants have multiple flowers)
    private List<GameObject> flowerPlants;

    // A lookup dictionary for looking up a flower from a nectar collider
    private Dictionary<Collider, Flower> nectarFlowerDictionary;

    /// <summary>
    /// The list of all flowers in the flower area
    /// </summary>
    public List<Flower> Flowers { get; private set; }

    /// <summary>
    /// Reset the flowers and flower plants
    /// </summary>
    public void ResetFlowers()
    {
        // Rotate each flower plant around the Y axis and subtly around X and Z
        foreach (GameObject flowerPlant in flowerPlants)
        {
            float xRotation = UnityEngine.Random.Range(-5f, 5f);
            float yRotation = UnityEngine.Random.Range(-180f, 180f);
            float zRotation = UnityEngine.Random.Range(-5f, 5f);
            flowerPlant.transform.localRotation = Quaternion.Euler(xRotation, yRotation, zRotation);
        }

        // Reset each flower
        foreach (Flower flower in Flowers)
        {
            flower.ResetFlower();
        }
    }

    /// <summary>
    /// Gets the <see cref="Flower"/> that a nectar collider belongs to
    /// </summary>
    /// <param name="collider">The nectar collider</param>
    /// <returns>The matching flower</returns>
    public Flower GetFlowerFromNectar(Collider collider)
    {
        return nectarFlowerDictionary[collider];
    }

    /// <summary>
    /// Called when the area wakes up
    /// </summary>
    private void Awake()
    {
        // Initialize variables
        flowerPlants = new List<GameObject>();
        nectarFlowerDictionary = new Dictionary<Collider, Flower>();
        Flowers = new List<Flower>();
    }

    /// <summary>
    /// Called when the game starts
    /// </summary>
    private void Start()
    {
        // Find all flowers that are children of this GameObject/Transform
        FindChildFlowers(transform);
    }

    /// <summary>
    /// Recursively finds all flowers and flower plants that are children of a parent transform
    /// </summary>
    /// <param name="parent">The parent of the children to check</param>
    private void FindChildFlowers(Transform parent)
    {
        for (int i = 0; i < parent.childCount; i++)
        {
            Transform child = parent.GetChild(i);

            if (child.CompareTag("flower_plant"))
            {
                // Found a flower plant, add it to the flowerPlants list
                flowerPlants.Add(child.gameObject);

                // Look for flowers within the flower plant
                FindChildFlowers(child);
            }
            else
            {
                // Not a flower plant, look for a Flower component
                Flower flower = child.GetComponent<Flower>();
                if (flower != null)
                {
                    // Found a flower, add it to the Flowers list
                    Flowers.Add(flower);

                    // Add the nectar collider to the lookup dictionary
                    nectarFlowerDictionary.Add(flower.nectarCollider, flower);

                    // Note: there are no flowers that are children of other flowers
                }
                else
                {
                    // Flower component not found, so check children
                    FindChildFlowers(child);
                }
            }
        }
    }
}
