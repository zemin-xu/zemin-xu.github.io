---
layout: post
author: zemin 
category: HCI
demo: true
demo_link: kart_game.mov
---

# Lab C : Machine Learning project with Unity

## Tranditional AI vs AI trained by Machine Learning
Traditional AI is implemented by programmers by setting specific rules and states. For example, for navigation of AI, there are different pathfinding algorithm. Different to traditional way, we do not provide specific implementation for the AI, also called agents. We make them "intelligent" by training with a reward system. The agents will try interacting with their environment and they will get different rewards according to their behaviours. Of course, the reward logic is set by programmers. The machine learning way will update their way to get the maximum reward.

## ML-Agents
The Unity Machine Learning Agents Toolkit (ML-Agents) is an open-source project that enables games and simulations to serve as environments for training intelligent agents. Agents can be trained using reinforcement learning, imitation learning, neuroevolution, or other machine learning methods through a simple-to-use Python API.

## hummingbird

### observation
bool, raycast
tuto's ideas: agents current rotation(queternion), dir and dis to nearest flower, becks to point at the flower, raycast to avoid obstacles

### reward
positive, negative

turn to the nearest flower : 10p
move to : 1p
get beck into it : 100p
finish a flower: 10000p

ideas in tuto:
a small positive : birds beak in flower
a big negative : touching ground and rocks

## project setup

###

``` c#
using UnityEngine;

public class Flower : MonoBehaviour
{
    /// <summary>
    /// Manages a single flower with nectar
    /// </summary>

    [Tooltip("The color when the flower is full")]
    public Color fullFlowerColor = new Color(1f, 0f, .3f);

    [Tooltip("The color when the flower is full")]
    public Color emptyFlowerColor = new Color(.5f, 0f, 1f);

    [HideInInspector]
    public Collider nectarCollider;

    private Collider flowerCollider;
    private Material flowerMaterial;

    public Vector3 FlowerUpVector
    {
        get
        {
            return nectarCollider.transform.up;
        }
    }

    public Vector3 FlowerCenterposition
    {
        get
        {
            return nectarCollider.transform.position;
        }
    }

    public float NectarAmount { get; private set; }

    /// <summary>
    /// whether the flower has any nectar remaining
    /// </summary>
    public bool HasNectar
    {
        get
        {
            return NectarAmount > 0f;
        }
    }

    /// <summary>
    /// attempts to remove nectar from the flower
    /// </summary>
    /// <param name="amount">the amount of nectar to remove</param>
    /// <returns>the amount successfully removed</returns>
    public float Feed(float amount)
    {
        // track how much nectar was successfully taken (cannot take more than is available)
        float nectarTaken = Mathf.Clamp(amount, 0f, NectarAmount);

        NectarAmount -= amount;

        if (NectarAmount <= 0)
        {
            NectarAmount = 0;

            flowerCollider.gameObject.SetActive(false);
            nectarCollider.gameObject.SetActive(false);

            flowerMaterial.SetColor("_BaseColor", emptyFlowerColor);
        }

        return nectarTaken;
    }

    public void ResetColor()
    {
        NectarAmount = 1f;

        flowerCollider.gameObject.SetActive(true);
        nectarCollider.gameObject.SetActive(true);

        flowerMaterial.SetColor("_BaseColor", fullFlowerColor);
    }

    private void Awake()
    {
        MeshRenderer meshRenderer = GetComponent<MeshRenderer>();
        flowerMaterial = meshRenderer.material;

        flowerCollider = transform.Find("FlowerCollider").GetComponent<Collider>();
        nectarCollider = transform.Find("FlowerNectarCollider").GetComponent<Collider>();
    }
}
```

``` c#
/// <summary>
/// manages a collection of flower plants
/// </summary>
public class FlowerArea : MonoBehaviour
{
    // the diameter of the area where the agent and flowers can be
    // used for observing relative distance from agent to flower
    public const float AreaDiameter = 20f;

    // the list of all flower plants in this flower area (flower plants have multiple flowers)
    private List<GameObject> flowerPlants;

    // a lookup dictionary for looking up a flower from a nectar collider
    private Dictionary<Collider, Flower> nectarFlowerDict;

    // the list of all flowers in the flower area
    public List<Flower> Flowers { get; private set; }

    // reset flowers and flower plants
    public void ResetFlowers()
    {
        // rotate each flower plant around the Y axis subtly around X and Z
        foreach (GameObject flowerPlant in flowerPlants)
        {
            float xRot = UnityEngine.Random.Range(-5f, 5f);
            float yRot = UnityEngine.Random.Range(-180f, 180f);
            float zRot = UnityEngine.Random.Range(-5f, 5f);

            flowerPlant.transform.localRotation = Quaternion.Euler(xRot, yRot, zRot);
        }

        foreach (Flower flower in Flowers)
        {
            flower.ResetFlower();
        }
    }

    /// <summary>
    /// get the <see cref="Flower"/> that a nectar collider belongs to
    /// </summary>
    /// <param name="collider">the nectar collider</param>
    /// <returns>the matching flower</returns>
    public Flower GetFlowerFromNectar(Collider collider)
    {
        return nectarFlowerDict[collider];
    }

    private void Awake()
    {
        flowerPlants = new List<GameObject>();
        nectarFlowerDict = new Dictionary<Collider, Flower>();
        Flowers = new List<Flower>();
    }

    private void Start()
    {
        FindChildFlowers(transform);
    }

    // recrusively find all flowers and flower plants that are children of a parent transform
    private void FindChildFlowers(Transform parent)
    {
        for (int i = 0; i < parent.childCount; i++)
        {
            Transform child = parent.GetChild(i);

            if (child.CompareTag("FlowerPlant"))
            {
                flowerPlants.Add(child.gameObject);

                // look for flowers within this flower plant
                FindChildFlowers(child);
            }
            else
            {
                Flower flower = child.GetComponent<Flower>();
                if (flower != null)
                {
                    Flowers.Add(flower);
                    nectarFlowerDict.Add(flower.nectarCollider, flower);
                }
                else
                {
                    // check this child
                    FindChildFlowers(child);
                }
            }
        }
    }
}
```



Unity introduces a useful tool that facilitates the installing step and management of different versions, call **Unity Hub**. The step here is quite simple: go to Unity's website and download this tool. After installation, we click the option **installs**, and find the version of the editor that we need to install. There will be a popup asking the extensions that we would like to add on it. I recommand adding **Visual Studio for Unity** and **Documentation**.

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab1/add_unity_version.png "add unity version"){:width="100%"}

&nbsp;

## License Management
By clicking the gear icon in *Unity Hub*, we can find a option called **License Management**. It is here that we enter the license info. Normally, we can use personal license for free. It is necessary to have a valide license, if not, we cannot open **Unity Editor**.

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab1/license.png "license"){:width="100%"}

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab1/new_license_activation.png "new license activation"){:width="100%"}

&nbsp;

## Create first project with Unity Editor
When a selected editor is already installed, we can create a project with this editor. By clicking the **new** button, a popup with different template will appear. By default, the **3D** template is chosen, meaning that there is only an empty scene for us. At the same time, we can choose a template with a framework on it. For example, here I choose **Karting Microgame**.

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab1/start_tutorials.png "start tutorials"){:width="100%"}

&nbsp;

### In-Editor tutorial
Since we are beginners right now, Unity provides a handy tool for us to quickly understand how editor works. We will click onto the first one which tell us how to make a play test.

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab1/playtest_1.png "play test starting button"){:width="100%"}

&nbsp;

Generally speaking, the Unity Editor is seperated by several windows. One of them is called **Game** window, previewing a visual result of our application. Different to **edit mode** in **Scene** window, in **Game** window it is called **play mode**.

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab1/playtest_2.png "play test enter play mode"){:width="100%"}

&nbsp;

The **play mode** can be stopped at any time by clicking on the same button of playing.

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab1/playtest_3.png "play test exit play mode"){:width="100%"}

&nbsp;

The **hierachy** window here shows all the [GameObjects](https://docs.unity3d.com/Manual/GameObjects.html) in scene. **Gameobject** is a specific term in Unity, meaning an object like the kart here, or an invisible one like the *GameManager* here.

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab1/playtest_4.png "play test hierachy window"){:width="100%"}

&nbsp;

The **inspector** window here shows all the [Components](https://docs.unity3d.com/Manual/Components.html) in scene. Normally, a *GameObject* makes up of several components which can be a script, a **Renderer** or so on. It is the components that define their gameobject. 

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab1/playtest_5.png "play test inspector window"){:width="100%"}

&nbsp;

Here, we are modifying the **top speed** variable on an attached script.

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab1/playtest_6.png "play test edit top speed variable"){:width="100%"}

&nbsp;

After retesting the game, we can find that the maximum speed of the kart is increased. That's all for the first tutorial and we have successfully set up the deveoping environment.

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab1/playtest_7.png "play test end"){:width="100%"}

### Personalized elements

We can try adding some personalized elements to know better how it works. Here, we will add an logo into the game. You can download the logo of my school -- IP-Paris [here](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab1/ip_paris_logo.png). We need to open the **project** windows which organizes all the assets in *Unity*, and drag & drop the file into **Assets/Karting/Art/Textures** folder.

&nbsp;

We will convert it as **sprite** firstly to use it as UI element.

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab1/addlogo_1.png "converting format"){:width="100%"}

&nbsp;

The next step is to create a **[Canvas](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/class-Canvas.html)** gameobject because we want to put onto it an image.

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab1/addlogo_2.png "convert format"){:width="100%"}

&nbsp;

By right clicking the *Canvas*, we are able to create an object whose parent is *Canvas*, we will create an **image** here.

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab1/addlogo_3.png "add Canvas"){:width="100%"}

&nbsp;

The next step is to modify *image's* property on *inspector* window, by dragging & dropping the logo into the corresponding case.

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab1/addlogo_4.png "add image"){:width="100%"}

&nbsp;

We will modify *image's* anchor in order to inherit the width and height of the parent object -- *Canvas*.

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab1/addlogo_5.png "add image"){:width="100%"}

&nbsp;

We will then change the **RenderMode** of component *Canvas* as *World Space*. Because we will put it in the game space instead of HUD. Finally we will rename the *Canvas* as *LogoLeft*, since we will put it on the left side of the starting line. We then duplicate one called *LogoRight*. We will adjust the their position and scale value in **Transform Component**, which are available in the images below. Let's try the game after doing it.

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab1/addlogo_6.png "transform component of logo right"){:width="100%"}

&nbsp;

![Alt text](https://raw.githubusercontent.com/zemin-xu/zemin-xu.github.io/master/assets/images/hci_lab1/addlogo_7.png "transform component of logo left"){:width="100%"}

&nbsp;

# References

[Creating your blog for free using Jekyll + Github pages](https://medium.com/20percentwork/creating-your-blog-for-free-using-jekyll-github-pages-dba37272730a)

[Create Your First Unity Project](https://learn.unity.com/tutorial/create-your-first-unity-project#5d0abe7bedbc2a16225ed3af)

[Beginner In-Editor Tutorials](https://learn.unity.com/tutorial/beginner-walkthroughs?courseId=5c59cf22edbc2a001f59aa5d)

&nbsp;